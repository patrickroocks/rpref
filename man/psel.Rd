% Generated by roxygen2 (4.1.1): do not edit by hand
% Please edit documentation in R/pref-eval.r
\name{psel}
\alias{psel}
\alias{psel.indices}
\title{Preference Selection}
\usage{
psel(df, pref, ...)

psel.indices(df, pref, ...)
}
\arguments{
\item{df}{A data frame or, for a grouped preference selection, a grouped data frame. See below for details.}

\item{pref}{The preference order constructed via \code{\link{complex_pref}} and \code{\link{base_pref}}.
All variables occurring in the definition of \code{pref} must be either columns of the data frame \code{df}
or variables/functions of the environment where \code{pref} was defined.}

\item{...}{Additional (optional) parameters for top(-level)-k selections:
 \describe{
   \item{\code{top}}{A \code{top} value of k means that the k-best tuples of the data set are returned.
    This may be non-deterministic, see below for details.}
    \item{\code{at_least}}{A \code{at_least} value of k returns the top-k tuples and additionally all tuples which are
    not dominated by the worst tuple (i.e. the minima) of the Top-k set.
    The number of tuples returned is greater or equal than
     \code{at_least}. In contrast to top-k, this is deterministic.}
    \item{\code{top_level}}{A \code{top_level} value of k returns all tuples from the k-best levels. See below for the definition of a level.}
    \item{\code{and_connected}}{Logical value, which is only relevant if more than one of the above \{\code{top}, \code{at_least}, \code{top_level}\}
    values is given, otherwise it will be ignored.
    Then \code{and_connected = TRUE} (which is the default) means that all top-conditions
    must hold for the returned tuples:
    Let \code{cond1} and \code{cond2} be top-conditions like \code{top=2} or \code{top_level=3}, then
    \code{psel([...], cond1, cond2)} is equivalent to the intersection of \code{psel([...], cond1)} and \code{psel([...], cond2)}. If we have
    \code{and_connected = FALSE}, these conditions are or-connected.
    This corresponds to the union of \code{psel([...], cond1)} and \code{psel([...], cond2)}.}
    \item{\code{show_level}}{Logical value. If \code{TRUE}, a column \code{.level}
    is added to the returned data frame, containing all level values.
    If at least one of the \{\code{top}, \code{at_least}, \code{top_level}\} values are given,
    then \code{show_level} is \code{TRUE} by default for the \code{psel} function.
    Otherwise, and for \code{psel.indices} in all cases, this option is \code{FALSE} by default.}
}}
}
\description{
Evaluates a preference on a given data set, i.e.,
returns the maximal elements of a data set for a given preference order.
}
\details{
The difference between the two variants of the preference selection is:

\itemize{
\item The \code{psel} function returns a subset of the data set which are the maxima according to the given preference.
\item The function \code{psel.indices} returns just the row indices of the maxima
(except top-k queries with \code{show_level = TRUE}, see top-k preference selection).
Hence \code{psel(df, pref)} is equivalent to \code{df[psel.indices(df, pref),]} for non-grouped data frames.
}
}
\section{Top-k Preference Selection}{


For a given \code{top} value of k the k best elements and their level values are returned. The level values are determined as follows:

\itemize{
\item{All the maxima of a data set w.r.t. a preference have level 1.}
\item{The maxima of the remainder, i.e., the data set without the level 1 maxima, have level 2.}
\item{The n-th iteration of "Take the maxima from the remainder" leads to tuples of level n.}
}

By default, \code{psel.indices} does not return the level values. By setting \code{show_level = TRUE} this function
returns a data frame with the columns '.indices' and '.level'.
Note that, if none of the top-k values \{\code{top}, \code{at_least}, \code{top_level}\} is set,
then all level values are equal to 1.

By definition, a top-k preference selection is non-deterministic.
A top-1 query of two equivalent tuples (equivalence according to \code{pref})
can return on both of these tuples.
For example, a \code{top=1} preference selection on the tuples {(a=1, b=1), (a=1, b=2)}
w.r.t. \code{low(a)} preference can return either the 'b=1' or the 'b=2' tuple.

On the contrary, a preference selection using \code{at_least} is deterministic by adding all tuples having the same level as the worst level
of the corresponding top-k query. This means, the result is filled with all tuples being not worse than the top-k result.
A preference selection with top-level-k returns all tuples having level k or better.

If the \code{top} or \code{at_least} value is greater than the number of elements in \code{df}
(i.e., \code{nrow(df)}), or \code{top_level} is greater than the highest level in \code{df},
then all elements of \code{df} will be returned without further warning.
}

\section{Grouped Preference Selection}{


Using \code{psel} it is also possible to perform a preference selection where the maxima are calculated for every group separately.
The groups have to be created with \code{\link{group_by}} from the dplyr package. The preference selection preserves the grouping, i.e.,
the groups are restored after the preference selection.

For example, if the \code{summarize} function from dplyr is applied to
\code{psel(group_by(...), pref)}, the summarizing is done for the set of maxima of each group.
This can be used to e.g., calculate the number of maxima in each group, see the examples below.

A \{\code{top}, \code{at_least}, \code{top_level}\} preference selection
is applied to each group separately.
A \code{top=k} selection returns the k best tuples for each group.
Hence if there are 3 groups in \code{df}, each containing at least 2 elements,
and we have \code{top = 2}, then 6 tuples will be returned.
}

\section{Parallel Computation}{


On multi-core machines the preference selection can be run in parallel using a divide-and-conquer approach.
Depending on the data set, this may be faster than a single-threaded computation.
To activate parallel computation within rPref the following option has to be set:

\code{options(rPref.parallel = TRUE)}

If this option is not set, rPref will use single-threaded computation by default.
}
\examples{
# Skyline and top-k/at-least skyline
psel(mtcars, low(mpg) * low(hp))
psel(mtcars, low(mpg) * low(hp), top = 5)
psel(mtcars, low(mpg) * low(hp), at_least = 5)

# visualize the skyline in a plot
sky1 <- psel(mtcars, high(mpg) * high(hp))
plot(mtcars$mpg, mtcars$hp)
points(sky1$mpg, sky1$hp, lwd=3)

# grouped preference with dplyr
library(dplyr)
psel(group_by(mtcars, cyl), low(mpg))

# return size of each maxima group
summarise(psel(group_by(mtcars, cyl), low(mpg)), n())
}
\seealso{
See \code{\link{complex_pref}} on how to construct a Skyline preference.
See \code{\link{plot_front}} on how to plot the Pareto front of a Skyline.
}

